Set
========

- 중복을 허용하지 않고, 순서가 중요하지 않은 자료 구조
- 중복을 허용하지 않으므로, 데이터가 같은지 확인하는 작업이 Set의 핵심
- 데이터 존재 여부를 확인하기 위한 용도로 주로 사용한다
- Set을 구현한 주요 클래스는 HashSet, TreeSet, LinkedHashSet이 있으며, 데이터 정렬 여부에 따라 특징이 나뉘게 된다
  - HashSet: 순서가 전혀 필요 없는 데이터를 해시 테이블에 저장. Set 중에 가장 성능이 좋음.
  - TreeSet: 저장된 데이터의 값에 따라 정렬되는 Set. red-black이라는 트리 타입으로 값이 저장되며, HashSet 보다 약간 성능이 느리다.
  - LinkedHashSet: 연결된 목록 타입으로 구현된 해시 테이블에 데이터를 저장. 저장된 순서에 따라서 값이 정렬됨. 셋 중에 성능이 가장 나쁨

## HashSet

- Set 인터페이스 구현체 중 가장 많이 사용되는 클래스
- Set에는 순서가 없기 때문에 순서가 매개 변수로 넘어가는 메소드나, 수행 결과가 데이터의 위치와 관련된 메소드는 Set 인터페이스에는 존재하지 않는다.

### 생성자

| 생성자 | 설명 |
|-|-|
| HashSet() | 데이터를 저장할 수 있는 16개의 공간과 0.75 로드 팩터를 갖는 객체를 생성한다 |
| HashSet(Collection<? extends E> c) | 매개 변수로 받은 컬렉션 객체의 데이터를 HashSet에 담는다 |
| HashSet(int initialCapacity) | 매개 변수로 받은 개수만큼의 데이터 저장 공간과 0.75 로드 팩터를 갖는 객체를 생성한다 |
| HashSet(int initialCapacity, float loadFactor) | 매개 변수로 받은 개수만큼의 데이터 저장 공간과 두번째 매개 변수만큼의 로드 팩터를 갖는 객체를 생성한다 |

#### ※ 로드 팩터
- (데이터의 개수) / (저장 공간)
- 데이터 개수가 증가하여 로드 팩터보다 커지면, 자료 구조를 다시 생성하는 refresh 필요.
- 로드 팩터가 클 수록 공간은 넉넉해지지만, 데이터를 찾는 시간은 증가


### 주요 메소드

| 리턴 타입 | 메소드 이름, 매개 변수 | 설명 |
|-|-|-|
| boolean | add(E e) | 데이터 추가 |
| void | clear() | 모든 데이터 삭제 |
| Object | clone() | HashSet 객체를 복제. 하지만, 담겨 있는 데이터들은 복제하지 않음 |
| boolean | contains(Object o) | 지정한 객체가 존재하는지를 확인 |
| boolean | isEmpty() | 데이터가 있는지 확인 |
| Iterator<E> | iterator() | 데이터를 꺼내기 위한 Iterator 객체를 리턴 |
| boolean | remove(Object o) | 매개 변수로 넘어온 객체를 삭제 |
| int | size() | 데이터의 개수를 리턴 |