Java HashMap
========

## Hash Table의 구조

- 연관배열 구조를 이용하여 키에 결과 값을 저장하는 자료구조
- 키는 해시함수를 통해 해시로 변경이 되며, 해시는 값과 매칭되어 저장소에 저장이 됨

> 연관배열 구조(associative array): 키 1개와 값 1개가 1:1 연관되어 있는 자료 구조

### 키(Key)
- 고유한 값
- 해시 함수의 input

### 해시 함수(Hash Function)
- 키를 해시로 변경
- 다양한 길이의 키를 일정한 길이를 가지는 해시로 변경하여 저장소를 효율적으로 운영할 수 있도록 함
- 서로 다른 키가 같은 해시가 되는 경우를 해시 충돌이라 하는데, 해시 충돌을 일으키는 확률을 최대한 줄이는 함수를 만드는 것이 중요

### 해시(Hash)
- 해시 함수의 결과물
- 저장소(Bucket)에서 값과 매칭되어 저장됨

### 값(Value)
- 저장소에 최종적으로 저장되는 값
- 해시와 매칭되어 저장, 삭제, 검색, 접근이 가능해야 함


## 해시 분포와 해시 충돌
- Boolean, Integer 등의 Number 객체는 객체의 값 자체를 해시 값으로 사용할 수 있으므로 완전한 해시 함수 대상으로 삼을 수 있음
- String, POJO 에 대한 완전한 해시 함수를 만드는 것은 사실상 불가능
- HashMap은 기본적으로 각 객체의 hashCode() 메소드가 반환하는 값을 사용
  - 결과 자료형은 int(2^32)
  - 32비트 정수 자료형으로는 완전한 자료 해시 함수를 만들 수 없음
  - 모든 HashMap에서 O(1)을 보장하기 위해 랜덤 접근이 가능하게 하려면, 원소가 2^32인 배열을 모든 HashMap이 가지고 있어야 하기 때문
- 해시 함수를 이용하는 연관 배열 구현체는 메모리를 절약하기 위해 실제 해시 함수의 표현 정수 범위보다 작은 M개의 원소가 있는 배열만을 사용
  - 객체에 대한 해시 코드의 나머지 값을 해시 버킷 인덱스 값으로 사용
  - `int index = X.hashCode() % M`
  - 이 방식은 서로 다른 해시 코드를 가지는 서로 다른 객체가 1/M의 확률로 같은 해시 버킷을 사용하게 됨
- 해시 충돌에 대한 해결책으로 Open Addressing과 Separate Chaning 방식이 있음

## 해시 충돌 해결책

### Open Addressing

- 데이터를 삽입하려는 해시 버킷이 이미 사용 중인 경우 비어있는 다른 해시 버킷에 해당 데이터를 삽입하는 방식
- 비어 있는 해시를 찾는 과정은 동일해야 함(일정한 규칙이 있어야 함)
  - 선형 탐색: 다음 해시나 n개를 건너뛰어 비어있는 해시에 데이터를 저장
  - 제곱 탐색: 충돌이 일어난 해시의 제곱을 한 해시에 데이터를 저장
  - 이중 해시: 다른 해시함수를 한 번 더 적용한 해시에 데이터를 저장
- 해시 테이블은 1개의 해시와 1개의 값이 매칭되는 형태가 유지됨
- 배열의 크기가 커질수록(M 값이 커질수록) 캐시 효율이 낮아짐
  - 배열의 크기가 커지면 L1, L2 캐시 적중률이 낮아지기 때문
- 데이터 삭제 처리가 효율적이기 어려움
- 해시 버킷을 채운 밀도가 높아질수록 Worst Case 발생 빈도가 높아짐

### Separate Chaning

- 각 배열의 인자는 인덱스가 같은 해시 버킷을 연결한 링크드 리스트의 첫 부분
- 해시 충돌이 잘 발생하지 않도록 조정할 수만 있다면 Worst Case 또는 Worst Case에 가까운 일이 발생하는 것을 줄일 수 있음
- Java HashMap에서는 Separate Chaning을 이용
  - Java 8에서는 해시 버킷에 할당된 키-값 쌍의 개수를 기준으로 링크드 리스트와 트리 자료 구조를 취사 선택함
  - 이 때 사용하는 트리는 Red-Black Tree


## 해시 버킷 동적 확장

- 해시 버킷의 개수가 적다면 메모리 사용을 아낄 수 있지만, 해시 충돌로 인한 성능상의 손실이 발생
- HashMap은 키-값 쌍 데이터 개수가 일정 개수 이상이 되면, 해시 버킷의 개수를 두 배로 늘림
  - 기본값은 16
  - 버킷의 최대 개수는 2^30
- 버킷 개수가 증가할 때마다 모든 키-값 데이터를 읽어 새로운 Separate Chaning을 구성해야 하기 때문에, HashMap 객체에 저장될 데이터의 개수가 어느 정도 예측이 가능한 경우에는 객체 생성 시 사이즈를 지정하면 불필요한 Separate Chaning을 줄일 수 있음


## 보조 해시 함수

- `index = X.hashCode() % M`을 계산할 때 사용하는 M 값은 소수일 때 index 값 분포가 가장 균등할 수 있음
  - M 값이 소수가 아니기 때문에 별도의보조 해시 함수를 이용하여 index 값 분포가 가급적 균등할 수 있도록 해야 함
- 키의 해시 값을 변형하여, 해시 충돌 가능성을 줄이는데 목적이 있음
- Java 8의 경우 상위 16비트 값을 XOR 연산한 값을 보조 해시 함수로 사용
  - 해시 충돌이 많이 발생하면 링크드 리스트 대신 트리를 사용하므로, 해시 충돌 시 발생할 수 있는 성능 문제가 완화됨
  - 최근의 해시 함수는 균등 분포가 잘 되게 만들어지는 경향이 많아 Java 7까지 사용했던 보조 해시 함수의 효과가 크지 않기 때문

--------
### 참고
- [Java HashMap은 어떻게 동작하는가?](https://d2.naver.com/helloworld/831311)
- [Hash, Hashing, Hash Table(해시, 해싱 해시테이블) 자료구조의 이해](https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o)

