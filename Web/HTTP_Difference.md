HTTP/1.1 과 HTTP/2.0
========

## HTTP

- Hypertext Transfer Protocol
- 웹상에서 클라이언트와 웹서버간 통신을 위한 프로토콜 중 하나


## HTTP/1.x 의 커넥션 관리

![connection](https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png)


### 단기 커넥션

- HTTP의 기본 모델
- 각각의 HTTP 요청은 각각의 커넥션 상에서 실행

### 영속 커넥션

- HTTP/1.1에 추가. keep-alive 커넥션이라고도 불림
- 일정 시간 동안 커넥션을 유지시키고 여러 요청에 재사용함으로써, TCP 핸드셰이크 비용을 아끼고 성능을 향상
- 연결된 socket에 IN/OUT의 access가 마지막으로 종료된 시점부터 정의된 시간까지 access가 없더라도 대기하는 구조. 정의된 시간내에 access가 이루어진다면 커넥션을 계속 유지할 수 있음.

### HTTP 파이프라이닝

- 영속적인 커넥션을 통해 이전 요청의 응답을 기다리지 않고 요청을 연속적으로 보내는 기법
- 갖은 버그 및 디버깅의 어려움, 구현의 복잡성, HOL 등의 이유로 모던 웹브라우저 대부분이 파이프라이닝 대신 복수의 커넥션을 이용해 요청을 병렬로 처리하여 데이터를 가져오는 방식을 사용


## HTTP/1.1의 단점

### 구조적 한계

- 연결 하나당 하나의 요청을 처리하는 구조
- 동시 전송 불가능
- 요청과 응답이 순차적으로 이루어짐
- 이러한 문제로 HTTP 문서에 필요한 복수의 리소스 처리 시 레이턴시가 길어짐

### HOL(Head Of Line) Blocking

- HTTP 요청은 현재의 요청에 대한 응답을 받고 나서야 다음 요청을 실시하는 순차적 구조
- 파이프라이닝 기법을 사용하더라도 데이터를 순차적으로 받아야 하기 때문에 HOL 문제를 여전히 가지고 있음
- TCP 연결은 신뢰성 있는 데이터 전송을 제공해야 하므로 중간에 패킷이 유실된 경우 반드시 복구를 해야함
- 하나의 커넥션에 복수의 요청을 순차적으로 보내는 경우 중간에 있는 요청이나 응답에서 패킷 유실이 발생할 시 그 요청이 복구될 때까지 지연 시간이 발생하고 그 다음 요청도 그만큼 지연이 발생


### RTT(Round Trip Time) 증가

- Keep-Alive 기능을 이용하여 커넥션을 재사용하지 않는다면, 매 요청마다 커넥션을 생성해야 하기 때문에 TCP 핸드셰이크가 반복적으로 발생하여 RTT 증가

> RTT: 요청 패킷을 보내고 난 뒤 응답 내용의 패킷이 도착하는 왕복 시간


### 무거운 Header

- HTTP/1.1의 헤더에는 많은 메타 정보들이 저장되어 있음
- 웹 페이지 방문 시 다수의 비동기 요청이 발생하게 되는데, 매 요청마다 중복된 헤더 값을 전송하게 되며 각 도메인에 설정된 쿠키 정보도 매 요청시 마다 헤더에 포함되어 전송됨


## HTTP/2

![http2](https://developers.google.com/web/fundamentals/performance/http2/images/binary_framing_layer01.svg?hl=ko)

- 구글이 만든 SPDY를 기반으로 표준화한 것. - 기존 HTTP의 메소드, 상태코드 등을 변경하지 않고 전송 방법만을 재정의하여 성능 향상을 이룸
- 바이너리 프레이밍 계층을 사용해 요청과 응답의 멀티플렉싱을 지원하는 것이 핵심
  - HTTP 메시지를 바이너리 형태의 프레임으로 나누고 이를 전송 후 받은 쪽에서 다시 조립

## 스트림, 메시지 및 프레임

### 스트림

- 구성된 연결 내에서 전달되는 바이트의 양방향 흐름
- 하나 이상의 메시지가 전달될 수 있음

### 메시지

- 논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스

### 프레임

- HTTP/2에서 통신의 최소 단위이
- 각 최소 단위에는 하나의 프레임 헤더가 포함
- 프레임 헤더는 최소한으로 프레임이 속하는 스트림을 식별


## 주요 특징

### Multiplexed Streams

- 여러 HTTP 요청/응답을 하나의 TCP 커넥션에서 전송. 각각의 HTTP 요청/응답은 요청별로 스트림이라는 단위로 전송되고 스트림 안에 여러개의 프레임이 존재
- HTTP/1.1의 Keep-Alive, 파이프라이닝의 개선

### Stream Prioritization

- 리소스간 우선순위를 설정하여 리소스 전송 지연에 따른 렌더링 지연을 최소화


### Server Push

- HTML 문서에 포함된 리소스를 클라이언트의 명시적인 요청이 없더라도 전송시킬 수 있어 클라이언트의 요청을 최소화시킴


### Header Compression

- Header 정보를 압축하기 위해 Header Table과 Huffman Encoding 기법을 사용하여 처리(HPACK 압축 방식)
- Header에 중복값이 존재하는 경우 Static/Dynamic Header Table 개념을 사용하여 중복 Header를 검출하고 중복된 Header는 index값만 전송하고 중복되지 않은 Header정보의 값은 Huffman Encoding 기법으로 인코딩 처리 하여 전송

