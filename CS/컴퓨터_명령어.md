컴퓨터 명령어
========

## 1. 개요

- 컴퓨터 명령어(instruction)는 컴퓨터가 수행해야 하는 일을 나타내기 위한 비트들의 집합으로 일정한 형식을 가짐
- 디지털컴퓨터는 명령어와 그것의 수행에 필요한 데이터가 주기억장치에 연속적으로 저장되어 있고, 이것을 중앙처리장치가 하나씩 순차적으로 수행하는 내장 프로그램(stored-program) 구조


## 2. 명령어의 구성

- 명령어는 필드(field)라 불리는 몇 개의 비트 그룹으로 나누어지며, 연산코드(operation code) 필드와 오퍼랜드(operand) 필드로 구성됨
  - 연산코드: 수행할 연산을 위한 명령어를 나타내는 연산코드 필드
  - 오퍼랜드: 연산코드에서 결정된 명령을 수행할 대상이 되는 데이터 또는 데이터가 저장된 주소를 나타내는 오퍼랜드 필드
- 명령어를 구성하는 필드들의 수와 배치방식 및 각 필드의 비트수를 명령어 형식이라 하며, 경우에 따라 2개 또는 3개의 필드로 구성될 수 있음
- 컴퓨터 명령어들은 크게 다음 네 가지 기능을 수행
  - 함수연산기능
  - 전달기능
  - 제어기능
  - 입출력기능


## 3. 명령어 형식

- 명령어 집합(instruction set): 그 컴퓨터에서 사용할 수 있는 명령어의 집합
- 모든 컴퓨터는 자신의 명령어 집합을 가지고 있으며, 이러한 명령어 집합은 그 컴퓨터의 구조적인 특성을 나타내는 가장 중요한 정보
- 서로 다른 컴퓨터들은 서로 다른 명령어 집합을 가짐
- 컴퓨터 계열에 속하는 컴퓨터들은 컴퓨터 자체가 다르더라도 시행되는 명령어 집합이 같음
- 명령어의 길이는 컴퓨터 성능에 영향을 준다
  - 명령어의 길이가 길면 주기억장치에 저장된 명령어를 인출할 때 많은 수의 비트가 주기억장치와 중앙처리장치 사이에 이동되어야 하므로 주기억장치 밴드 폭을 많이 사용하게 되어 비효율적
  - 일반적으로 2~3개의 오퍼랜드를 사용


### 3.1 기억장소에 따른 명령어 형식

오퍼랜드를 기억시켜 놓는 장소에 따라 명령어 형식은 **누산기**를 이용하는 경우와 **다중 레지스터**를 이용하는 경우, 그리고 **스택 구조**를 이용하는 경우로 분류된다

#### 1) 누산기를 이용한 명령어 형식

- 함수연산기능의 명령어를 수행할 때 오퍼랜드들 중의 하나가 누산기에 기억되도록 하는 컴퓨터 구조
- 누산기를 가진 컴퓨터 구조에서 누산기는 중앙처리장치 내에 있는 유일한 데이터 레지스터
- 누산기가 있는 컴퓨터 구조에서 수행되는 모든 연산은 누산기 레지스터를 대상으로 수행됨
- 명령어 형식은 1-주소 명령어로서 하나의 기억장치 주소 필드를 사용

#### 2) 다중 레지스터를 이용한 명령어 형식

- 중앙처리장치 내에 여러 개의 레지스터를 가지고 있는 컴퓨터 구조
- 다중 레지스터를 가진 컴퓨터 구조에서 사용하는 명령어 형식은 중앙처리장치 내의 2개 이상의 레지스터를 사용하여 연산을 수행
- 2-주소 명령어 또는 3-주소 명령어를 사용

#### 3) 스택 구조를 이용한 명령어 형식

- 스택 구조 컴퓨터는 연산에 필요한 오퍼랜드를 기억장치 스택에 기억시켜야 하고, 연산의 결과도 스택에 기억시키는 구조
  - 기억장치 스택: 스택 구조의 특성을 가진 기억장치의 한 부분
- 스택 구조 명령어는 0-주소 명령어로서 명령의 수행에 필요한 2개의 오퍼랜드가 스택에 저장되어 있음
  - 오퍼랜드가 기억되어 있는 곳을 알 수 있으므로 명령어 형식에 주소 필드를 표기하지 않아도 됨
- 스택 구조에서 사용하는 함수 연산기능의 명령어 형식은 연산코드만 나타냄
- 필요한 오퍼랜드가 스택에 있고, 연산결과도 스택에 기억되므로 주소 필드가 따로 필요하지 않음


### 3.2 오퍼랜드의 수에 따른 명령어 형식

- 오퍼랜드의 수에 따른 명령어 형식은 오퍼랜드가 주소를 나타낼 때 오퍼랜드 수에 따라 3-주소, 2-주소, 1-주소 명령여 형식으로 구분됨
- 주소 수가 많아질수록 명령어가 복잡해짐
- 레지스터의 수가 많아져 연산속도가 빨라지고 프로그램이 짧아져 프로그램당 명령어의 수가 감수
- 주소 수가 적어질수록 명령어는 간단해지고 인출속도가 높아지지만 프로그램의 길이는 증가

#### 1) 3-주소 명령어

| 연산코드 | 오퍼랜드1 | 오퍼랜드2 | 오퍼랜드3 |
|-|-|-|-|

- 오퍼랜드가 3개인 명령어 형식
- 산술식을 프로그램화할 때 그 프로그램의 길이가 짦음
- 3-주소 명령어를 2진 코드화 했을 때 3개의 오퍼랜드를 나타내기 위한 비트수가 다른 주소 명령어 형식보다 많이 필요

#### 2) 2-주소 명령어

| 연산코드 | 오퍼랜드1 | 오퍼랜드2 |
|-|-|-|

- 오퍼랜드가 2개인 명령어 형식
- 상업용 컴퓨터에서 가장 많이 사용되는 명령어 형식
- 2-주소 명령어는 3-주소 명령어에 비해 명령어의 길이는 짧아졌으나, 같은 내용을 수행하기 위해 수행해야 하는 명령어의 수가 증가함

#### 3) 1-주소 명령어

| 연산코드 | 오퍼랜드1 |
|-|-|

- 오퍼랜드가 1개인 명령어 형식
- 기억장치로부터 오퍼랜드를 가져오거나, 연산결과를 저장하기 위한 임시적인 장소로 **누산기 레지스터**를 이용
- 모든 연산은 누산기 레지스터와 기억장치에 저장된 오퍼랜드를 대상으로 수행됨
- 프로그램을 수행하기 위해 사용되는 명령어의 수가 증가

#### 4) 0-주소 명령어

| 연산코드 |
|-|

- 함수연산을 수행할 때 주소 필드를 사용하지 않음
- 산술연산에 관련된 명령어들을 수행할 때 **기억장치 스택**을 사용
- 기억장치 스택의 TOS로부터 아래에 있는 오퍼랜드를 가져오고, 수행 후 연산 결과를 스택의 TOS에 저장
- 명령어의 길이가 매우 짧아서 기억공간을 적게 차지
- 특수한 경우를 제외하고는 많은 양의 정보가 스택과 주기억장치 사이를 이동하게 되어 비효율적


## 4. 주소지정방식

| 연산코드 | 주소지정방식 | 주소 혹은 오퍼랜드 |
|-|-|-|

- 오퍼랜드를 실제로 참조하기 전에 명령어의 오퍼랜드를 변경하거나 해석하는 규칙을 지정하는 형식
- 이러한 규칙의 적용에 의해 만들어진 오퍼랜드 주소를 유효주소라고 함
- 명령어의 수를 더욱 줄일 수 있는 효과적인 프로그램을 작성할 수 있음
- 연산코드 필드는 수행할 연산의 종류를 지정
- 주소지정방식 필드는 연산에 필요한 오퍼랜드의 주소를 알아내는 데 사용
- 주소 필드는 존재할 수도 있고 안할 수도 있으며, 주소 필드가 존재한다면 그 필드는 기억장치주소 혹은 레지스터 주소를 나타냄

### 4.1 의미주소지정

- 주소 필드가 필요없는 방식(의미 방식, implied mode)
- 연산코드 필드에 지정된 묵시적인 의미로 인하여 오퍼랜드를 지정
- 명령어 자체가 오퍼랜드를 AC 레지스터에 저장하고 있다는 것을 내포
- 오퍼랜드가 생략되므로 명령어의 길이가 짧아짐
- 명령어의 종류가 제한됨

### 4.2 즉치주소지정

- 명령어의 오퍼랜드 필드에 저장된 내용이 명령어에서 사용될 실제 데이터를 나타내는 방식
- 프로그램에서 레지스터나 변수의 초기값을 특정 상수값으로 초기화하는데 매우 유용
- 오퍼랜드 필드가 곧 데이터이므로 데이터 인출을 위한 기억장치 접근이 필요하지 않아 속도가 빠름
- 데이터의 크기가 오퍼랜드 필드의 비트수에 의해 제한됨

### 4.3 직접주소지정과 간접주소지정

#### 1) 직접주소지정방식

- 명령어의 주소 필드에 직접 오퍼랜드의 주소를 저장시키는 주소지정방식
- 명령어의 대상이 되는 데이터를 접근하는 데 기억장치르 한 번만 접근하면 된다
- 오퍼랜드 필드의 길이에 따라 접근할 수 있는 기억장치의 주소공간에 한계가 있음

#### 2) 간접주소지정방식

- 명령어의 주소 필드에 유효주소가 저장되어 있는 기억장치주소를 기억시키는 주소방식
- 제어는 기억장치로부터 명령어를 가져온 후 주소 부분을 이용하여 다시 기억장치에 접근하여 유효주소를 읽어냄
- 접근할 수 있는 기억장치 주소공간이 중앙처리장치가 한 번에 접근할 수 있는 단어의 길이로 결정됨
- 실행 사이클 동안 두 번의 기억장치 접근이 필요
- 주소 지정 방식을 간접주소지정방식으로 나타내는 방식 필드(mode)가 필요
  - 직접주소지정방식: 0
  - 간접주소지정방식: 1


### 4.4 레지스터 주소지정과 레지스터 간접주소지정

#### 1) 레지스터 주소지정방식

- 오퍼랜드 필드에서 지정한 레지스터에 실제 피연산자가 들어 있는 방식
- 오퍼랜드에는 레지스터 번호가 저장되며 유효주소는 존재하지 않음
- 오퍼랜드 필드가 레지스터들의 번호를 나타내기 때문에 오퍼랜드 필드의 비트가 적어도 사용 가능
- 데이터 인출을 위해 기억장치에 접근하지 않고 중앙처리장치의 레지스터로 접근하므로 속도가 빠름
- 오퍼랜드가 중앙처리장치의 레지스터의 수가 제한되어 있으므로 무한정 사용할 수 없음


#### 2) 레지스터 간접주소지정방식

- 명령어 내의 주소 필드가 레지스터 중 하나를 지정하고, 지정된 레지스터의 내용은 실제 오퍼랜드가 저장된 기억주소장치를 지정
- 지정된 레지스터는 오퍼랜드 그 자체가 아니라 오퍼랜드가 저장된 기억장치주소를 가지고 있음


### 4.5 상대주소지정

- 유효주소를 계산하기 위해 처리장치 내에 있는 특정 레지스터의 내용에 명령어 오퍼랜드를 더하는 방식
- 자주 사용되는 레지스터는 PC
- `유효주소 = 명령어 주소 부분의 내용 + PC의 내용`


### 4.6 인덱스된 주소지정

- 인덱스 레지스터의 내용을 명령어 주소 부분에 더해서 유효주소를 얻는 방식
- 인덱스 레지스터는 특정한 CPU 레지스터나 레지스터 파일에 있는 레지스터가 될 수 있음
- 주로 배열을 인덱싱할 때 많이 사용됨
- `유효주소 = 명령어 주소 부분의 내용 + 인덱스 레지스터의 내용`


### 4.7 주소지정방식의 요약

| 주소값 | 내용 |
|-|-|
| 250 | 연산코드, 주소지정방식 |
| 251 | ADRS, NBR = 500 |
| 252 | 다음 명령어 |
| 400 | 700 |
| 500 | 800 |
| 752 | 600 |
| 800 | 300 |
| 900 | 200 |

- ADRS(혹은 NBR) = 500
- PC = 250
- R1 = 400

| 주소지정방식 | 기호표기 | 레지스터 전송 | 유효주소 | AC의 이용 |
|-|-|-|-|-|
| 즉치주소 | LDA #NBR | AC ← NBR | 251 | 500 |
| 직접주소 | LDA ADRS | AC ← M[ADRS] | 500 | 800 |
| 간접주소 | LDA[ADRS] | AC ← M[M[ADRS]] | 800 | 300 |
| 상대주소 | LDA $ADRS | AC ← M[ADRS + PC] | 752 | 600 |
| 인덱스 주소 | LDA ADRS(R1) | AC ← M[ADRS + R1] | 900 | 200 |
| 레지스터 주소 | LDA R1 | AC ← R1 | - | 400 |
| 레지스터 간접주소 | LDA (R1) | AC ← M[R1] | 400 | 700 |


## 5. 명령어 종류

- 컴퓨터마다 서로 다른 명령어 집합을 가지지만, 명령어 집합 중 기본적으로 사용되는 명령어는 크게 다르지 않다
- 대부분의 컴퓨터 명령어는 크게 세 가지로 나누어짐
  - 데이터 전송 명령어
  - 데이터 처리 명령어
  - 프로그램 제어 명령어


### 5.1 데이터 전송 명령어

| 이름 | 니모닉 | 기능 |
|-|-|-|
| Load | LD | 기억장치로부터 레지스터로의 전송 |
| Store | ST | 레지스터로부터 기억장치로의 전송 |
| Move | MOVE | 레지스터로부터 다른 레지스터로, 기억장소에서 다른 기억장소로의 이동 |
| Exchange | XCH | 두 레지스터 간 또는 레지스터와 기억장치간의 데이터 교환 |
| Push | PUSH | 기억장치의 스택과 레지스터 간의 데이터 전송 |
| Pop | POP | 기억장치의 스택과 레지스터 간의 데이터 전송 |
| Input | IN | 레지스터와 입출력장치 간의 데이터 전송 |
| Output | OUT | 레지스터와 입출력장치 간의 데이터 전송 |

- 2진 정보의 내용을 변화시키지 않고 한 장소에서 다른 장소로 단지 데이터를 전송하는 것
- 레지스터-레지스터, 레지스터-기억장치, 기억장치-기억장치 사이에 데이터를 이동하는 기능
- 데이터 전송 명령어에는 입출력 명령어가 포함됨


### 5.2 데이터 처리 명령어

- 데이터에 대한 연산을 실행하고 컴퓨터에 계산능력을 제공
- 산술 명령어, 논리와 비트 처리 명령어, 시프트 명령어로 나눌 수 있음

#### 1) 산술 명령어

| 이름 | 니모닉 | 기능 |
|-|-|-|
| Increment | INC | 1 증가 |
| Decrement | DEC | 1 감소 |
| Add | ADD | 덧셈 |
| Subtract | SUB | 뺄셈 |
| Multifly | MUL | 곱셈 |
| Divide | DIV | 나눗셈 |
| Add with carry | ADDC | 캐리를 포함한 덧셈 |
| Subtrack with borrow | SUBB | 빌림을 포함한 뺄셈 |
| Negate | NEG | 2의 보수 |

- 대부분의 컴퓨터는 사칙연산에 대한 산술 명령어를 모두 제공
- 소규모 컴퓨터의 경우 덧셈과 뺄셈의 명령어만 가질 수도 있음
  - 그 경우 곱셈과 나눗셈은 프로그램화되어 수행됨
- 사칙연산만으로도 수칙해석법에 의해 어떠한 계산문제에 대한 해를 구하는 것은 충분


#### 2) 논리 및 비트 처리 명령어

| 이름 | 니모닉 | 기능 |
|-|-|-|
| Clear | CLR | 모든 비트를 0으로 리셋 |
| Set | SET | 모든 비트를 1로 세트 |
| Complement | COM | 모든 비트를 반전 |
| AND | AND | 비트별 AND 연산 |
| OR | OR | 비트별 OR 연산 |
| Exclusive-OR | XOR | 비트별 XOR 연산 |
| Clear carry | CLRC | 캐리비트의 리셋 |
| Set carry | SETC | 캐리비트의 세트 |
| Complement carry | COMC | (반전) 보수 |

- 논리연산 명령어는 레지스터나 기억장치에 저장된 단어에 대해 2진 연산을 수행
- 주로 2진 부호화 정보를 표현하는 비트 그룹이나 개별 비트를 처리하는 데 사용함
- 논리연산 명령어는 오퍼랜드의 각 비트를 독립적으로 간주하여 각 비트를 부울식의 한 변수로서 처리


#### 3) 시프트 명령어

| 이름 | 니모닉 | 기능 |
|-|-|-|
| Logical shift right | SHR | 오른쪽 시프트(왼쪽의 남는 비트는 0으로 채움) |
| Logical shift left | SHL | 왼쪽 시프트(오른쪽의 남는 비트는 0으로 채움) |
| Arithmetic shift right | SHRA | 부호비트는 고정(왼쪽의 남는 비트는 부호비트로 채움) |
| Arithmetic shift left | SHLA | 부호비트는 고정(오른쪽의 남는 비트는 0으로 채움) |
| Rotate right | ROR | 오른쪽으로 순환(버려지는 비트는 다시 왼쪽 비트로) |
| Rotate left | ROL | 왼쪽으로 순환(버려지는 비트는 다시 오른쪽 비트로) |
| Rotate right with carry | RORC | 캐리를 포함한 오른쪽 순환 |
| Rotate left with carry | ROLC | 캐리를 포함한 왼쪽 순환 |

- 오퍼랜드의 비트를 왼쪽이나 오른쪽으로 이동시키는 동작
- 단어의 끝에서 시프트되어 들어오는 비트가 어떻게 처리되느냐에 따라서 시프트의 형태가 달라짐


### 5.3 프로그램 제어 명령어

| 이름 | 니모닉 | 기능 |
|-|-|-|
| Branch | BR | 조건 혹은 무조건적으로 유효주소로 분기 |
| Jump | JMP | 조건 혹은 무조건적으로 유효주소로 분기 |
| Skip next instruction | SKP | 조건이 만족되면 다음 명령어를 수행하지 않고 넘어감 |
| Call procedure | CALL | 서브루틴 호출 |
| Return from procedure | RET | 서브루틴 실행 후 복귀 |
| Compare (by substraction) | CMP | 두 오퍼랜드의 뺄셈을 통해 상태 레지스터의 값을 반환 |
| Test (by ANDing) | TEST | 논리 AND 연산만 구현 |

- 프로그램 명령어들은 기억장치에 연속적으로 저장됨
- 제어장치에 의해 명령어가 처리될 때, 명령어는 어떠한 기억장소로부터 연속적으로 읽어 내어 하나씩 수행됨
- 명령어를 기억장치에서 가져올 때마다 프로그램 카운터(PC)는 1씩 증가되어 다음 순서로 읽어 올 명령어의 주소를 가지게 됨
- 프로그램 제어 명령어를 수행하면 프로그램 카운터의 주소값과 제어흐름이 바뀜
- 프로그렘 제어 명령어의 수행결과로 발생하는 프로그램 카운터값의 변화는 수행할 명령어의 순서를 다르게 함
  - 이전 계산결과에 따라서 프로그램 수행의 흐름을 제어하거나 다른 프로그램 세그먼트로 분기할 수 있는 능력을 제공하기 때문
  