DML
========

- 데이터 조작어(Data Manipulation Language)
- SELECT, INSERT, UPDATE, DELETE


## 1. INSERT

- 테이블에 데이터를 입력할 때 사용
- 테이블에 데이터를 입력하는 방법으로는 두 가지가 있음
- 한 번에 한 건의 데이터만 입력됨

1. `INSERT INTO 테이블명(컬럼 목록) VALUES (값 목록);`
- 값을 입력할 컬럼들을 정의하고 그 컬럼에 해당하는 값을 입력하는 방법
- 정의하지 않은 컬럼에 대해서는 NULL이 입력됨

2. `INSERT INTO 테이블명 VALUES (전체 컬럼에 대한 값 목록)`
- 값을 입력할 컬럼을 정의하지 않고 입력하는 방법
- 컬럼 목록을 정의하지 않았다면 모든 컬럼 값이 컬럼 순서대로 입력되어야 한다

## 2. UPDATE

`UPDATE 테이블명 SET 수정할_컬럼명 = 수정하려는_값 [WHERE 조건]`

- 데이터의 값을 변경할 때 사용
- WHERE 조건으로 특정 ROW를 지정하지 않으면 모든 ROW가 변경된다


## 3. DELETE

`DELETE [FROM] 테이블명 [WHERE 조건]`

- 테이블의 데이터를 삭제할 때 사용
- WHERE 조건으로 특정 ROW를 지정하지 않으면 모든 ROW가 삭제된다

### ※ DB의 DDL, DML 처리 방식 차이

- DDL은 직접 DB의 테이블에 영향을 미치기 때문에 Auto Commit 된다
- DML은 조작하려는 테이블을 메모리 버퍼에 올려놓고 작업하기 때문에 직접 Commit을 입력하여 트랜잭션을 종료해야 한다
- 단, SQL Server의 경우 DML의 경우에도 Auto Commit 처리 된다

### ※ 데이터 삭제 방식 차이
| DROP | TRUNCATE | DELETE |
|-|-|-|
| DDL | DDL<br>(일부 DML 성격 가짐) | DML |
| Rollback 불가능 | Rollback 불가능 | Commit 이전에는 Rollback 가능 |
| Auto Commit | Auto Commit | 사용자 Commit |
| 테이블이 사용했던 저장 공간을 모두 해제 | 테이블이 사용했던 저장 공간중 최초 테이블 생성시 할당된 저장 공간만 남기고 해제 | 데이터를 모두 삭제해도 사용했던 저장 공간은 해제되지 않음 |
| 테이블의 정의 자체를 완전히 삭제함 | 테이블을 최초 생성된 초기상태로 만듬 | 데이터만 삭제 |

- DROP, TRUNCATE TABLE은 로그를 남기지 않는다
- TRUNCATE은 UNDO를 위한 데이터를 생성하지 않기 때문에 동일 데이터량 삭제시 DELETE보다 빠르다

## 4. SELECT

`SELECT [옵션] 컬럼1, 컬럼2, ... FROM 테이블명`

- 입력된 데이터를 조회할 때 사용
- ALL: 기본 옵션. 중복된 데이터가 있어도 모두 출력
- DISTINCT: 중복된 데이터가 있는 경우 1건으로 처리해서 출력하는 옵션

### ALIAS 부여

`컬럼명 [AS] 별명 `

- 조회된 결과에 일종의 별명을 부여
- 컬럼명 바로 뒤에 온다
- 컬럼명과 ALIAS 사이에 AS, as 키워드를 사용할 수도 있다
- 별명 사이에 공백이나 특수문자를 포함할 경우, 대소문자 구분이 필요한 경우 이중 인용부호(`" "`)로 감싼다


## 5. 산술 연산자와 합성 연산자

### 가. 산술 연산자

- NUMBER와 DATE 자료형에 대해 적용
- 일반적으로 수학에서의 사칙연산과 동일
- 우선순위 적용을 위한 괄호 적용이 가능

### 나. 합성 연산자

- 문자와 문자를 연결하는 연산자
- Oracle은 문자와 문자를 연결하는 경우 2개의 수직 바(`||`)를 이용
- SQL Server는 `+` 표시를 이용
- 두 벤더 모두 `CONCAT(string1, string2)` 함수 이용 가능
- 컬럼과 문자 또는 다른 컬럼과 연결
- 문자 표현식의 결과에 의해 새로운 컬럼을 생성
