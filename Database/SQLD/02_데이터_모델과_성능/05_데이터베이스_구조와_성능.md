데이터베이스 구조와 성능
========

## 1. 슈퍼타입/서브타입 모델의 성능고려 방법

### 가. 슈퍼/서브타입 데이터 모델의 개요

- 업무를 구성하는 데이터의 특징을 공통과 차이점의 특징을 고려하여 효과적으로 표현하는 데이터 모델
- 공통의 부분을 슈퍼타입으로 모델링하고, 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브엔터티로 구분하여 업무의 모습을 정확하게 표현
- 물리적인 데이터 모델을 변환할 때 선택의 폭을 넓힐 수 있음
- 논리적인 데이터 모델에서 이용되는 형태
- 분석 단계에서 많이 쓰이는 모델


### 나. 슈퍼/서브타입 데이터 모델의 변환

- 슈퍼/서브타입을 성능을 고려한 물리적인 데이터 모델로 변환하는 기준은 데이터 양과 해당 테이블에 발생되는 트랜잭션의 유형에 따라 결정된다
- 슈퍼/서브타입에 대한 변환을 잘못하면 성능이 저하되는 이유는 **트랜잭션 특성을 고려하지 않고 테이블이 설계되었기 때문**
    - 트랜잭션은 항상 일괄로 처리하는데 테이블은 개별로 유지되어 Union연산에 의해 성능이 저하될 수 있다
    - 트랜잭션은 항상 서브타입 개별로 처리하는데 테이블은 하나로 통합되어 있어 불필요하게 많은 양의 데이터가 집약되어 있어 성능이 저하되는 경우
    - 트랜잭션은 항상 슈퍼+서브 타입을 공통으로 처리하는데 개별로 유지되어 있거나 하나의 테이블로 집약되어 있어 성능이 저하되는 경우

### 다. 슈퍼/서브타입 데이터 모델의 변환기술

#### 1) 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
- 슈퍼타입과 서브타입 각각에 대해 독립적으로 트랜잭션이 발생이 되면 슈퍼타입에도 꼭 필요한 속성만을 가지게 하고 서브타입에도 꼭 필요한 속성 및 자신이 타입에 맞는 데이터만 가지게 하기 위해서 모두 분리하여 1:1 관계를 가지도록 한다

#### 2) 슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
- 슈퍼타입과 서브타입을 묶어 트랜잭션이 발생하는 업무특성을 가지고 있을 때에는 다음 데이터 모델과 같이 슈퍼타입+각 서브타입을 하나로 묶어 별도의 테이블로 구성하는 것이 효율적
- 업무적인 특성상 실전 프로젝트에서 슈퍼타입/서브타입 모델은 위와 같이 각각이 슈퍼타입+서브타입으로 묶여 구성하는 경우가 많다


## 2. 인덱스 특성을 고려한 PK/FK 데이터베이스 성능향상

### 가. PK/FK 컬럼 순서와 성능개요

- 일반적으로 DB 테이블은 **B*Tree** 구조를 많이 사용하며, 그 특징에 따른 설계를 할 필요가 있다
- 테이블에 발생되는 트랜잭션의 조회 패턴에 따라 PK/FK 컬럼 순서를 조정해야 한다
- PK는 해당 테이블의 데이터를 접근할 때 가장 빈번하게 사용되는 UNIQUE 인덱스를 모두 자동 생성하며, 이러한 인덱스를 효율적으로 이용할 수 있도록 PK순서를 지정해야 한다
- 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때(복합키), 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다.
  - 앞쪽에 위치한 속성 값이 가급적 `=`, `BETWEEN`, `<>` 가 들어와야 인덱스를 이용할 수 있다

### 나. PK컬럼의 순서를 조정하지 않으면 성능이 저하되는 이유

- SQL 구문의 조건에 따라 인덱스를 처리하는 범위가 달라지는데, 맨 앞에 있는 컬럼이 제외된 상태에서 데이터를 조회할 경우 데이터를 비교하는 범위가 매우 넓어지게 되어 성능이 저하된다
    - 인덱스의 범위를 넓게 이용하거나 전체를 읽어야만 하는 상황이 발생
- 인덱스를 읽고 테이블 블록에서 읽어 처리하는데 I/O가 많이 발생하게 되므로, 옵티마이저는 인덱스를 이용하지 않고 테이블 풀스캔을 선택하게 된다


### ※ PK 속성이 A+B, B+A 형태로도 조회되는 경우

- 좀 더 자주 이용되는 조회의 형태대로 PK 순서를 구성하여 이용하도록 하고, 순서를 바꾼 인덱스를 추가로 생성하여 해결한다


## 3. 물리적인 테이블에 FK제약이 걸려있지 않을 경우 인덱스 미생성으로 성능저하

- 물리적인 테이블에 FK를 사용하지 않아도 데이터 모델 관계에 의해 상속받은 FK속성들은 SQL WHERE 절에서 조인으로 이용되는 경우가 많이 있으므로 FK 인덱스를 생성해야 성능이 좋아지는 경우가 빈번하다