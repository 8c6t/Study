스프링 프로젝트 시작하기
========

## 애플리케이션 아키텍처

- 아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어
  - 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것
  - 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 행위와 깊은 연관이 있음

## 1. 계층형 아키텍처

- 성격이 다른 모듈이 강하게 결합되어 한데 모여 있으며 한 가지 이유로 변경이 일어날 때 그와 상관이 없는 요소도 함께 영향을 받게 된다
- 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요
- 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 계층형 아키텍처 혹은 멀티 티어 아키텍처라고 부른다
- 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3계층 애플리케이션이라고도 한다

### 3계층 아키텍처와 수직 계층

- 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 **데이터 액세스 계층**
- 비즈니스 로직을 담고 있는 **서비스 계층**
- 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 **프레젠테이션 계층**


#### 1) 데이터 액세스 계층

- DAO 계층이라고도 불림
- 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임
- 데이터 액세스 계층은 사용 기술에 따라서 다시 세분화 된 계층으로 구분될 수 있는데, 데이터 액세스 계층 안에서 다시 세분화하는 경우는 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고 부르기도 함

#### 2) 서비스 계층

- 비즈니스 로직을 담는 계층
- 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성됨
  - POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다
- 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어지며, 때로는 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다
  - 원칙적으로 서비스 계층 코드가 기반 서비스 계층의 코드에 종속되면 안 된다
  - 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 종속성을 제거해야 한다
  - 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 함
- 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층 구조를 가질 필요가 없다
- **이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바뀌고, 클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다**

#### 3) 프레젠테이션 계층

- 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있음
- 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 됨
- 프레젠테이션 계층은 다른 계층과 달리 클라이언트까지 그 범위가 확장될 수도 있다
- 스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를 제공하며, 그 외의 다양한 서드파티 웹 기술을 지원한다


### 계층형 아키텍처 설계의 원칙

- 어떤 경우에라도 계층 사이의 낮은 결합도를 깨트리지 않도록 설계해야 한다
  - 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다
- 계층 레벨에 정의한 인터페이스를 통해서 요청을 하게 되고, 계층 간에 사용되는 인터페이스 메소드에는 특정 계층의 기술이 최대한 드러나지 않게 만들어야 한다
  - 계층 사이의 호출은 인터페이스를 통해 이루어져야 한다
  - 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 한다
- 데이터 액세스 예외와 같이 특별한 경우에만 전달될 가능성이 있는 것은 스프링의 DataAccessException 처럼 런타임 예외로 만들어야 한다
  - 특별한 이유로 데이터 액세스 예외를 다뤄야 하는 경우에라도 특정 구현 방식에 종속되지 않는 추상적인 형태로 만들어줘야 한다
- 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달해서는 안 된다
  - 서블릿의 HttpServletRequest나 HttpServletResponse, HttpSession 같은 타입을 서비스 게층 인터페이스 메소드의 파라미터 타입으로 사용하면 안 된다
- 한 계층의 내부에서만 사용되도록 만든 빈 오브젝트를 DI를 통해 다른 게층에서 함부로 가져다 쓰는 일은 피해야 한다
- 중간 계층을 건너뛰어서 관계를 갖지 않는 계층의 빈을 직접 DI하지 않도록 주의해야 한다


## 2. 애플리케이션 정보 아키텍처

- 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다
- 엔터프라이즈 애플리케이션에 존재하는 데이터를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우로 구분할 수 있다

### 데이터 중심 아키텍처

#### 1) DB/SQL 중심의 로직 구현 방식

- 데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조
- DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 프레젠테이션 계층의 뷰와 연결해주는 것
  - 보통 DB에서 돌려주는 내용을 그대로 맵이나 단순 결과 저장용 오브젝트에 넣어서 전달
  - SQL은 이미 화면에 어떤 식으로 출력이 될지 알고 있는 셈
  - 프레젠테이션 계층의 뷰는 DAO의 SQL에서 정확히 어떤 필드 값을 리턴할지, 어떤 포맷으로 전달할지 알고 있음
  - DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에 흘러다니는 정보는 항상 단순한 포맷의 데이터
- 데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의 저장 프로시저나 SQL에 담겨 있는 경우가 많음
- 객체지향 기술이나 언어를 사용하지 않던 시절의 엔터프라이즈 애플리케이션과 크게 다를 바가 없음
  - 자바 코드의 로직은 기껏해야 사용자 요청에 따라서 어떤 SQL을 가진 DAO를 실행할지를 결정하는 정도
  - 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시킴
  - 자바의 오브젝트는 단지 HTTP 서비스 채널을 만들어주고 JDBC를 이용해 DB 기능을 사용하게 하는 스크립트 정도로 역할이 축소됨
- 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 강함
  - 모든 계층의 코드가 하나의 작업에 종속됨
  - 대부분의 코드는 대응되는 작업 단위에 1:1로 매핑됨
  - 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경됨
  - 종속적일 뿐 아니라 배타적이여서 다른 단위 업무에 재사용되기 힘듬
  - 유사한 방법의 DAO 메소드일지라도 화면에 나타날 정보가 다르면 SQL이 달라지기 때문에 새로 만들어야 함
  - 업무 트랜잭션 단위로 코드를 묶어서 만들지 기능을 세분화해서 분리하고 재사용하지 않기 때문
- **겉으로 보기에는 각 계층이 독립적으로 보이지만, 그 사이를 이동하는 데이터가 일종의 접착제 역할을 해서 강한 결합을 만들게 됨**
- 객체지향의 장점이 별로 활용되지 못하는데다 각 계층의 코드가 긴밀하게 연결되어 있다
- 로직을 DB와 SQL에 많이 담으면 담을수록 점점 확장성이 떨어진다
  - DB는 확장에 한계가 있을 뿐 아니라 확장한다 하더라도 매우 큰 비용이 필요
  - 복잡한 SQL을 처리하기 위해서 제한된 자원인 DB에 큰 부담을 주게 됨
- 로직을 DB보다는 애플리케이션으로 가져오는 편이 비용, 안정성, 코드 검증 등의 측면에서 유리

#### 2) 거대한 서비스 계층

- DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법
- 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것
- 거대 서비스 게층 방식에서는 DAO에서 좀 더 단순한 결과를 돌려준다
- DAO가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 됨
- DAO와 SQL은 상대적으로 단순해지고, 그중 일부는 여러 서비스 계층 코드에서 재사용이 가능해짐
- 상대적으로 단순한 DAO 로직을 사용하고, 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방법은 결국 거대한 서비스 계층을 만들게 됨
  - 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉬움
  - 서비스 계층의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메소드에서 중복돼서 나타나기 쉬움
  - DAO에 복잡한 조건의 로직을 넣지는 않더라도 **서비스 계층에서 필요한 정보를 한 번에 SQL을 통해 가져오고, 그 값을 저장하는 방식이 일관성 없이 매번 달라질 수 있기 때문에** 서비스 계층의 코드나 DAO에 적지 않은 중복이 발생
- 계층별로 독립된 설계와 개발이 어렵고, 개발이 진행되면서 구현할 비즈니스 로직이나 설계에 변경이 생기거나 유지보수 중에 수정할 필요가 있을 경우 코드를 손대기 쉽지 않을 수 있다

> 데이터 중심 아키텍처의 특징은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진다는 점


## 3. 오브젝트 중심 아키텍처

- 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 점이 가장 큰 차이
- **객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용함**
- 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 오브젝트 중심 아키텍처
- 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담기므로 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채 사용될 수 있음
- 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있음
- 코드의 재사용성은 높아지고 DAO는 더 작고 효율적으로 만들어질 수 있음
- 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수 있음
- 지연된 로딩 기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB에서 다시 읽어올 수 있다
- 자주 변경되지 않으면서 많은 로직에서 참조하는 레퍼런스 테이블이 있다면 이를 ORM이 제공하는 오브젝트 캐시에 담아두고 사용할 수도 있다
- 코드 테이블처럼 자주 참조되는 것은 오브젝트 캐시로 만들어두면 매번 DB에서 읽어오지 않고 메모리 캐시에 가져오게 해주기 때문에 DB의 부하를 줄여줘서 성능이 많이 향상됨

### 빈약한 도메인 오브젝트 방식

- 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트라 보기 힘든데, 이런 오브젝트를 빈약한 오브젝트라 부름
- 계층 사이의 독립성을 확보하기 위해서는 특정 계층에 종속되지 않으면서 애플리케이션 전반에서 사용될 수 있는 정보를 담은 오브젝트가 필요하기에 빈약한 도메인 오브젝트 방식도 실제로 많이 사용됨
- 다루는 정보의 구조가 다를 뿐이지 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷함

### 풍성한 도메인 오브젝트 방식

- 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것
- 어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있음
- 이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것
- 도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하기도 함
  - 수식 계산이나 조건에 따른 데이터의 변경 또는 자신이 가진 정보에 대한 분석 같은 도메인 오브젝트 자신에 국한된 로직은 도메인 오브젝트 안에 추가할 수 있지만, 그 결과를 DB에 저장하거나 메일로 발송하거나 DB를 검색해서 원하는 정보를 가져와 활용하는 작업은 도메인 오브젝트에서는 불가능
  - DAO와 기반계층 오브젝트를 DI 받아 사용할 수 있는 서비스 계층의 코드가 필요

### 도메인 계층 방식

- 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 방식
- 도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층 사이에 존재하게 하는 것
- 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다
- 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다
- 스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요
  - AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트가 만들어지는 시점을 조인 포인트로 사용할 수 있고, 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가기능을 적용할 수 있음
- 매우 복잡하고 변경이 잦은 도메인을 가졌을 경우 고려해볼 수 있는 방법


## 4. 스프링 애플리케이션을 위한 아키텍처 설계

### 계층형 아키텍처

- 3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조
- 3계층이라는 것은 논리적이고 개념적인 구분이지 꼭 오브젝트 단위로 끊어져서 만들어지는 게 아님을 염두해야 함
- 3계층을 단순화해서 2계층으로 만든다면 서비스 계층과 데이터 액세스 계층을 통합하는 것이 낫다
  - 논리적으로는 서비스 계층과 데이터 액세스 계층의 경계를 분명히 하는 것이 좋음
- 프레젠테이션 계층은 보통 MVC라는 이름으로 잘 알려진 패턴 또는 아키텍처를 주로 사용
- 스프링은 이 MVC 중 가장 부담을 많이 지고 있는 컨트롤러에 해당하는 부분을 또 다시 세분화해서 여러 단계의 오브젝트로 만들 수 있도록 설계됨

### 정보 전송 아키텍처

- 스프링의 기본 기술에 가장 잘 들어맞고 쉽게 적용해볼 수 있는 것은 오브젝트 중심 아키텍처의 도메인 오브젝트 방식
- 가능하다면 도메인 오브젝트에 단순한 기능이라도 추가하도록 노력해보는 것이 좋음
- 도메인 오브젝트를 사용해 애플리케이션의 정보를 일관된 형태로 유지하는 게 스프링에 가장 잘 들어맞는 방식

### 상태 관리와 빈 스코프

- 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하게 하기 위해 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작함
- 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않는다는 특징이 있음
- 하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업정보는 유지돼야 한다
  - 이를 위해 웹 클라이언트에 URL, 파라미터, 폼 히든 필드, 쿠키 등을 이용해 상태정보 또는 서버에 저장된 상태정보에 키 값 등을 전달해야 함
- 스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장
