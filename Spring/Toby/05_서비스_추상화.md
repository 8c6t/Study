서비스 추상화
========

## 코드 개선

- 코드에 중복된 부분은 없는가?
- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?
- 객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다


## 테스트 시의 대역

- 장애가 발생했을 때 일어나는 현상 중의 하나인 예외가 던져지는 상황을 의도적으로 만든다
- 예외를 강제로 발생시키도록 코드를 수정하는 것이 가장 간단
  - 원 코드를 수정하는 것은 매우 위험
  - 테스트용으로 특별히 대역 클래스를 만드는 것이 바람직
  - 상속을 통해 테스트에 필요한 기능을 추가하도록 일부 메소드를 오버라이딩
- 테스트에서만 사용할 클래스라면 번거롭게 파일을 따로 만들지 말고 테스트 클래스 내부에서 스태틱 클래스로 만드는 것이 간편


## 트랜잭션 경계설정

- DAO를 사용하는 비즈니스 로직에서는 단위 작업을 보장해주는 트랜잭션이 필요하다
- 트랜잭션의 시작과 종료를 지정하는 일을 트랜잭션 경계설정이라고 한다. 트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다
- 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있음
- 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우 트랜잭션의 경계를 설정할 필요가 있음
- 모든 트랜잭션은 시작하는 지점과 끝나는 지점이 있음
- 시작하는 방법은 하나이지만 끝나는 방법은 두 가지
  - 모든 작업을 무효화시키는 롤백
  - 모든 작업을 다 확정시키는 커밋
- 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치를 트랜잭션의 경계라고 함
- JDBC는 기본적으로 DB 작업을 수행한 직후에 자동으로 커밋이 되도록 설정되어 있음
- setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback() 으로 트랜잭션을 종료하는 작업을 트랜잭션의 경계 설정이라고 함


## Service 객체 트랜잭션 경계설정의 문제점

- DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 JdbcTemplate을 더 이상 활용할 수 없음
- DAO의 메소드와 비즈니스 로직을 담고 있는 Service의 메소드에 Connection 파라미터가 추가되어야 함
- Connection 파라미터가 DAO 인터페이스 메소드에 추가되면 DAO는 더 이상 데이터 액세스 기술에 독립적일 수 없다
- DAO 메소드에 Connection 파라미터를 받게 하면 테스트 코드에도 영향을 미친다
- 비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다
  - 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메소드로 정리돼야 한다
- 이를 위해서는 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스와 DI를 잘 활용해서 결합도를 낮춰야 한다


## 트랜잭션 동기화

### Connection 파라미터 제거

- 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO에 전달하는 방법은 매우 비효율적이기 때문에 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리
- 스프링은 독립적인 트랜잭션 동기화 방식을 제안
- Service에서 트랜잭션을 시작히기 위해 만든 Connection 오브젝트를 특별한 저장소(트랜잭션 동기화 저장소)에 보관해두고, 이후에 호출되는 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 하는 것
- 트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌 염려가 없음
- 트랜잭션 동기화 기법을 사용하면 파라미터를 통해 일일히 Connection 오브젝트를 전달할 필요가 없음
- 트랜잭션의 경계설정이 필요한 메소드에서만 Connection을 다루게 하고, 여기서 생성된 Connection과 트랜잭션을 DAO의 JdbcTemplate이 사용할 수 있도록 별도의 저장소에 동기화하는 방법을 적용하기만 하면 된다


### 트랜잭션 동기화 적용

```java
TransactionSynchronizationManager.initSynchronization();
Connection c = DataSourceUtils.getConnection(dataSource);
c.setAutoCommit(false);

try {
  //...
  c.coimmit();
} catch (Exception e) {
  c.rollback();
  throw e;
} finally {
  DataSourceUtils.releaseConnection(c, dataSource);
  TransactionSynchronizationManager.unbimdResource(this.dataSource);
  TransactionSynchronizationManager.clearSynchronization();
}
```


- 스프링은 트랜잭션 동기화 기능을 지원하는 간단한 유틸리티 메소드를 제공함
- TransactionSynchronizationManager 클래스를 이용해 먼저 트랜잭션 동기화 작업을 초기화 하도록 요청
  - DataSourceUtil에서 재공하는 getConnection() 메소드를 통해 DB 커넥션을 생성
  - DB 커넥션을 직접 다룰 때 DataSource가 필요하므로 DataSource 빈에 대한 DI 설정이 필요
- DataSourceUtil의 getConnection() 메소드는 Connection 오브젝트를 생성해줄 뿐만 아니라 트랜잭션 동기화에 사용하도록 저장소에 바인딩도 해준다


## JdbcTemplate과 트랜잭션 동기화

- 미리 생성되서 트랜잭션 동기화 저장소에 등록된 DB 커넥션이나 트랜잭션이 없는 경우에는 JdbcTemplate이 직접 DB 커넥션을 만들고 트랜잭션을 시작해서 JDBC 작업을 진행
- 트랜잭션 동기화를 시작해놓았다면 그때부터 실행되는 JdbcTemplate의 메소드에서는 직접 DB 커넥션을 만드는 대신 트랜잭션 동기화 저장소에 들어 있는 DB 커넥션을 가져와 사용
- DAO를 사용할 때 트랜잭션이 굳이 필요 없다면 바로 호출해서 사용
- DAO 외부에서 트랜잭션을 만들고 이를 관리할 필요가 있다면 미리 DB 커넥션을 생성한 다음 트랜잭션 동기화를 해주고 사용


## 로컬 트랜잭션 / 글로벌 트랜잭션

- 한 개 이상의 DB로의 작업을 하나의 트랜잭션으로 만드는건 JDBC의 Connection을 이용한 트랜잭션 방식인 로컬 트랜잭션으로는 불가능
  - 로컬 트랜잭션은 Connection에 종속되기 때문
- 각 DB와 독립적으로 만들어지는 Connection을 통해서가 아닌, 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 **글로벌 트랜잭션** 방식을 사용
- 글로벌 트랜잭션을 지원하는 트랜잭션 매니저를 지원하기 위한 API인 JTA(Java Trasaction API)를 제공


## 스프링의 트랜잭션 서비스 추상화

- 하위 시스템의 공통점을 뽑아내서 분리시키는 것을 추상화라 한다
- 기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다
- 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다. 환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 변경되어야 한다
- 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며, DAO가 사용하는 특정 기술에 대해 강한 결합을 만들어낸다
- 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다
- 서비스 추상화는 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관된 API를 가진 추상화 계층을 도입한다
- 이를 이용하면 애플리케이션에서 직접 각 기술의 트랜잭션 API를 이요하지 않고도 일관된 방색으로 트랜잭션을 제어하는 트랜잭션 경계설정 작업이 가능해짐
- 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스는 PlatformTransactionManager
  - JDBC의 로컬 트랜잭션을 이용한다면 PlatformTransactionManager를 구현한 DataSourceTransactionManager를 사용
- TransactionStatu는 트랜잭션에 대한 조작이 필요할 때 PlatformTransactionManager 메소드의 파라미터로 전달


## 트랜잭션 기술 설정의 분리

- 글로벌 트랜잭션으로 변경이 필요한 경우 PlatformTransactionManager 구현 클래스를 DataSourceTrasactionManager에서 JTATransactionManager로 바꾸면 된다
- 어떤 트랜잭션 매니저 구현 클래스를 사용할지 Service 코드가 알고 있는 것은 DI 원칙에 위배되므로, 자신이 사용할 구체적인 클래스를 컨테이너를 통해 제공받는 스프링의 DI 방식을 이용
  - 스프링의 빈으로 등록할 때 먼저 검토해야 할 것은 싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은지 여부
- PlatformTransactionManager만 있으면 Service 객체에서 Connection 생성과 트랜잭션 경계설정 기능을 모두 이용할 수 있게 된다
- JtaTransactionManager는 애플리케이션 서버의 트랜잭션 서비스를 이용하기 때문에 직접 DataSource와 연동할 필요는 없지만, JTA를 사용하는 경우는 DataSource도 서버가 제공해주는 것을 사용해야 한다


## 단일 책임 원칙

- 단일 책임원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 의미
- 하나의 모듈이 바뀌는 이유는 한 가지여야 한다
- 단일 책임 원칙을 잘 지키고 있다면, 어떤 변경이 필요할 떄 수정 대상이 명확해진다
- 적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고, 애플리케이션 로직과 기술/환경을 분리하는 등의 작업은 갈수록 복잡해지는 엔터프라이즈 애플리케이션에는 반드시 필요하다


## 테스트 대역과 목 오브젝트

- 테스트 환경을 만들어주기 위해, 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게, 자주 테스트를 실행할 수 있도록 사용하는 오브젝트를 통틀에 테스트 대역이라 부름
- 테스트 스텁은 테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는 것을 말한다
- DI 등을 통해 미리 의존 오브젝트를 테스트 스텁으로 변경
- 테스트 대상의 간접적인 출력 결과를 검증하고, 테스트 대상 오브젝트와 의존 오브젝트 사이에서 일어나는 일을 검증할 필요가 있다면 목 오브젝트를 사용
