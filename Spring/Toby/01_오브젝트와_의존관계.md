오브젝트와 의존 관계
========

## 자바빈

두 관례를 따라 만들어진 오브젝트

1. 디폴트 생성자: **파라미터가 없는 디폴트 생성자가 필수**. 툴이나 프레임워크에서 **리플렉션을 이용해서 오브젝트를 생성**하기 때문
2. 프로퍼티: 자바빈이 노출하는 이름을 가진 속성. getter/setter 메소드를 이용해 수정 또는 조회


## 관심사의 분리

- 관심이 같은 것끼리는 하나의 객체 또는 그와 관련된 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지 않도록 분리
- 오브젝트에 대한 설계와 이를 구현한 코드는 항상 변하므로, 미래의 변화를 대비하여 객체를 설계해야 함
- 변화의 성격이 다르면 변화의 이유와 시기, 주기 등이 다르다
- 변화의 폭을 최소한으로 줄인다


## 디자인 패턴

- 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션
- 주로 객체지향 설계에 관한 것
- 객체지향적 설계 원칙을 이용해 문제를 해결
- 확장성 추구 방식은 대부분 ①클래스 상속, ②오브젝트 합성


## 템플릿 메소드 패턴

- 변하지 않는 기능은 슈퍼클래스에 만들어두고, 자주 변경되며 확장할 **기능**은 서브클래스에서 만들도록 함
- 필요에 맞게 구현해야 하는 메소드를 추상 메소드나 protected 등의 접근제어자로 오버라이딩이 가능한 메소드로 만든 뒤, 서브클래스에서 구현
- 훅 메소드: 슈퍼클래스에서 디폴트 기능으르 정의하거나 비워두고, 서브클래스에서 **선택적으로 오버라이드** 하도록 만들어둔 메소드


## 팩토리 메소드 패턴

- 슈퍼클래스 코드에서 서브클래스에서 구현할 메소드를 호출하여 필요한 타입의 오브젝트를 가져와 사용
- 서브클래스에서 **구체적인 오브젝트 생성 방법**을 결정
- 주로 인터페이스 타입으로 오브젝트를 리턴
- 팩토리 메소드: 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해 둔 메소드


## 상속을 이용하여 관심사를 분리했을 경우의 한계

1. 자바는 다중 상속을 지원하지 않기 때문에, 추후 다른 목적으로 상속을 적용하기 힘들어짐
2. 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있기 때문에, 상속관계는 다른 관심사에 대해 긴밀한 결합을 허용하고 있음


## 관계설정 책임의 분리

- 오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어짐
- 오브젝트 사이의 관계가 만들어지기 위해서는 만들어진 오브젝트가 필요
  - 직접 생성자를 호출하여 오브젝트를 만드는 방법
  - **외부에서 만들어준 것을 가져오는 방법**
    - 메소드 파라미터나 생성자 파라미터를 이용하여 외부에서 만든 오브젝트를 가져오는 방법
- **클라이언트에서 런타임 오브젝트 관계를 가지는 구조로 만들어준다**


## 개방 폐쇄 원칙

- 클래스나 모듈은 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다

### 높은 응집도

- 변화가 일어날 때, **해당 모듈**에서 변하는 부분이 크게 하는 것
- 모듈의 일부만 변경이 일어나도 된다면, 모듈 전체에서 어떤 부분이 바뀌어야 하는지 파악해야 하고, 그 변겨으올 인해 바뀌지 않은 부분에 다른 영향을 미치지 않는지 확인해야 함
- 분리를 통해 응집도를 높인다

### 낮은 결합도

- 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에 변화를 요구하는 정도를 낮추는 것
- 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도를 유지하도록 하는 것
- 관계를 유지하는 데 필요한 최소한의 방법만 간접적인 형태(인터페이스)로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것


## 전략 패턴

- 자신의 기능 맥락(컨텍스트)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
- 컨텍스트를 사용하는 클라이언트는 컨텍스트가 사용할 전략을 컨텍스트의 생성자 등을 통해 제공해주는 것이 일반적


## 제어의 역전(Inversion of Control)

- 오브젝트가 자신이 사용할 오브젝트를 **스스로 선택하거나 생성하지 않도록 하는 것**
- 제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계 설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요

### 팩토리

- 객체의 생성 방법을 결정하고, 그렇게 만들어진 오브젝트를 돌려주는 역할을 하는 오브젝트
- 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리할 목적으로 사용

### 컴포넌트와 팩토리

- 컴포넌트: 애플리케이션의 실질적인 로직을 담당하는 오브젝트
- 팩토리: 애플리케이션을 구성하는 컴포넌트의 구조와 관계(의존관계)를 정의한 설계도


## 프레임워크와 라이브러리의 차이

### 라이브러리

- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어함
- 단지, 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐

### 프레임워크

- 애플리케이션 코드가 프레임워크에 의해 사용됨
- 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만들 애플리케이션 코드를 사용하도록 만드는 방식
- 제어의 역전 개념이 적용되어야 함


## 스프링 IoC

### 스프링 빈

- 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
- 스프링 컨테이너가 생성과 관계 설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트

### 빈 팩토리

- 빈의 생성과 관계 설정 같은 제어를 담당하는 IoC 오브젝트
- 최상위 인터페이스로 BeanFactory가 존재
- 주로 BeanFactory의 구현체인 ApplicationContext를 이용


### 설정 정보 / 설정 메타정보

- 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
- 컨테이너에 어떤 기능을 세팅하거나 조정하는데 사용하거나, IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구현할 때 사용됨
- `@Configuration`: 애플리케이션 컨텍스트가 활용하는 **IoC 설정 정보**


## 오브젝트의 동일성과 동등성

### 동일성(Identical)

- 두 개의 오브젝트가 완전히 같은 경우
- `==` 연산자로 비교

### 동등성(Equivalent)

- 두 개의 오브젝트가 동일한 정보를 담고 있는 경우
- `equals()` 메소드로 비교
- `equals()` 메소드를 따로 구현하지 않았다면 최상위 클래스인 Object 클레스에 구현 된 메소드를 사용


## 싱글톤 패턴

- 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수만 존재하도록 강제하는 패턴
  - 이름에서처럼 주로 하나만 존재하도록 함
  - 만들어진 해당 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능
- 단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용
- 싱글톤은 멀티스레드 환경에서 여러 스레드가 동시에 접근해서 사용할 수 있기 때문에, 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 가지지 않도록 만들어야 함(stateless)
  - 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나, 파라미터로 주고 받으면서 사용해야 함
  - 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 괜찮다

### 싱글톤 패턴의 구현

- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private로 만듬
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의
- 스태틱 팩토리 메소드인 `getInstance()`를 만들고, 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 함.
  - 생성된 오브젝트는 스태틱 필드에 저장됨
  - 스태틱 필드의 초기값으로 오브젝트를 미리 만들어두는 경우도 있음
- 한 번 오브젝트(싱글톤)가 만들어지고 난 후에는 `getInstance()` 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨줌

### 싱글톤 패턴의 한계

- private 생성자를 가지고 있기 때문에 상속이 불가능함
- 생성 방식이 제한적이기 때문에 테스트가 어려움
- 서버에서 클래스 로더를 어떠헥 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있음
- 싱글톤의 사용은 전역 상태를 만들 수 있음


## 싱글톤 레지스트리

- 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공. 이를 싱글톤 레지스트리라 함
- 스태틱 메소드와 private 생성자를 사용하지 않고, 평범한 자바 클래스를 싱글톤으로 활용할 수 있게 해줌


## 의존관계 주입

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 **인터페이스에만 의존**하고 있어야 한다
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 **제3의 존재**가 결정한다
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로서 만들어진다


## 의존관계 검색

- 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만, **이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법**
- 스프링 애플리케이션 컨텍스트는 `getBean()` 메소드를 의존관계 검색에 사용
- 의존관계 검색 방법은 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타나게 됨
- 의존관계 검색 방식에서는 오브젝트는 자신이 스프링의 빈일 필요는 없음


## 의존관계 주입의 응용

### 기능 구현의 교환

- 개발관경과 운영환경에서의 DI의 설정 정보만 다르게 만들어 두면, 나머지 코드에는 전혀 손대지 않고 개발 시와 운영 시에 각각 다른 런타임 오브젝트에 의존관계를 갖게 할 수 있음


### 부가기능 추가

- 의존되는 인터페이스를 구현하며 부가기능을 추가하는 방식으로 기존 코드의 수정 없이 기능 추가가 가능
